# The Tuna Programming Language
![banner](banner.png)

A dynamically typed, interpreted programming language.

**Version: 0.9.0**  
**License: MIT**

## Overview
**Tuna** is a dynamically typed, interpreted programming language. This project is heavily inspired by and derived from the books **'Writing An Interpreter in Go'** & **'Writing A Compiler in Go'** by **Thorsten Ball** and the *Monkey* programming language.

As of *v0.9*, the language is fully functional as interpreter and supports functionality such as
- Simple data types - **Integers**, **Strings** and **Booleans**.
- Compound data types - **Lists** and **Maps**.
- **Prefix**, **Infix** and **Index** operations.
- **Conditional** and **Return** statements.
- **Global** and **Local** variable bindings.
- **First-class** functions and **Closures**.
- Simple **Built-In** functions.

## Usage
The only way to use **Tuna** currently is through the REPL (this will change).
1. Clone this repository and change into the root directory.
2. Use ``go run main.go`` to launch the **Tuna REPL**.

## Components

### The Lexer
The lexer converts string inputs into lexicological token that can be parsed. It is defined in ``lexer`` package along with the definitions for the lexicological tokens used in Tuna.

### The Parser
The parser is a top-down recursive descent parser that is often called a **Pratt parser**. It is defined in ``parser`` package. Its role is to converts the tokens generated by the lexer into an **Abstract Syntax Tree**. The nodes of the AST are defined in the ``syntaxtree`` package.

### The Evaluator
The evaluator is a tree-walking evaluator implemented in the ``evaluator`` package that recursively walks down the AST and evaluates it into objects that are defined by ``object`` package.

### The REPL
The read-eval-print loop accepts an input and interprets/evaluates it on the fly and prints the output. It is the primary interface to interact with the **Tuna** programming language.


## Examples
```bash
let name = "Monkey";
let age = 1;
let inspirations = ["Scheme", "Lisp", "JavaScript", "Clojure"];
let book = {
    "title": "Writing A Compiler In Go",
    "author": "Thorsten Ball",
    "prequel": "Writing An Interpreter In Go"
};

let printBookName = fn(book) {
    let title = book["title"];
    let author = book["author"];

    puts(author + " - " + title);
};

printBookName(book);
# => prints: "Thorsten Ball - Writing A Compiler In Go"
```

```bash
let fibonacci = fn(x) {
    if (x == 0) {
        0
    } else {
        if (x == 1) {
            return 1;
        } else {
            fibonacci(x - 1) + fibonacci(x - 2);
        }
    }
};

let map = fn(arr, f) {
    let iter = fn(arr, accumulated) {
        if (len(arr) == 0) {
            accumulated
        } else {
            iter(rest(arr), push(accumulated, f(first(arr))));
        }
    };
    iter(arr, []);
};

let numbers = [1, 1 + 1, 4 - 1, 2 * 2, 2 + 3, 12 / 2];
map(numbers, fibonacci);
# => returns: [1, 1, 2, 3, 5, 8]
```

## Future Development
- Unicode Lexer [[#1]](https://github.com/manishmeganathan/tuna/issues/1)
- Installable Binaries and Automated Release Workflow [[#5]](https://github.com/manishmeganathan/tuna/issues/5)
- Macro System [[#6]](https://github.com/manishmeganathan/tuna/issues/6)
- Bytecode Compiler and Virtual Machine (Tuna v2)
